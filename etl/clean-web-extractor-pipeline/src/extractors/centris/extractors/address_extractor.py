#!/usr/bin/env python3
"""
Extracteur sp√©cialis√© pour les adresses et coordonn√©es GPS
"""

import re
from typing import Optional, Tuple
from bs4 import BeautifulSoup
import structlog

logger = structlog.get_logger()

class AddressExtractor:
    """Extracteur sp√©cialis√© pour les adresses et coordonn√©es GPS"""
    
    def __init__(self, config=None):
        self.logger = logger
        self.config = config
    
    def extract_address(self, soup: BeautifulSoup) -> dict:
        """Extrait l'adresse compl√®te d'une propri√©t√©"""
        try:
            address_data = {}
            
            # Extraction de la rue
            street = self._extract_street(soup)
            if street:
                address_data['street'] = street
            
            # Extraction de la ville
            city = self._extract_city(soup)
            if city:
                address_data['city'] = city
            
            # Extraction de la r√©gion
            region = self._extract_region(soup)
            if region:
                address_data['region'] = region
            
            # Extraction du code postal
            postal_code = self._extract_postal_code(soup)
            if postal_code:
                address_data['postal_code'] = postal_code
            
            # Extraction du pays
            country = self._extract_country(soup)
            if country:
                address_data['country'] = country
            
            # Construction de l'adresse compl√®te
            if address_data:
                address_data['full_address'] = self._build_full_address(address_data)
            
            # Extraction des coordonn√©es GPS
            coordinates = self._extract_coordinates(soup)
            if coordinates:
                address_data['latitude'] = coordinates[0]
                address_data['longitude'] = coordinates[1]
            
            logger.debug(f"üìç Adresse extraite: {address_data}")
            return address_data
            
        except Exception as e:
            logger.error(f"‚ùå Erreur extraction adresse: {e}")
            return {}
    
    def _extract_street(self, soup: BeautifulSoup) -> Optional[str]:
        """Extrait la rue depuis le HTML"""
        try:
            # 1. Recherche dans les √©l√©ments d'adresse schema.org (priorit√© haute)
            address_elem = soup.find('h2', {'itemprop': 'address'})
            if address_elem:
                address_text = address_elem.get_text(strip=True)
                # Format: "608 - 612, boulevard Brassard, Chambly"
                street = self._extract_street_from_address(address_text)
                if street:
                    logger.debug(f"üè† Rue trouv√©e (schema.org): {street}")
                    return street
            
            # 2. Recherche dans les √©l√©ments d'adresse sp√©cifiques
            address_elem = soup.find('span', {'data-id': 'Address'})
            if address_elem:
                street = address_elem.get_text(strip=True)
                logger.debug(f"üè† Rue trouv√©e (data-id): {street}")
                return street
            
            # 3. Recherche alternative
            address_elem = soup.find('h1', class_='property-title')
            if address_elem:
                street = address_elem.get_text(strip=True)
                logger.debug(f"üè† Rue trouv√©e (titre): {street}")
                return street
            
            return None
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur extraction rue: {e}")
            return None
    
    def _extract_city(self, soup: BeautifulSoup) -> Optional[str]:
        """Extrait la ville depuis le HTML"""
        try:
            # 1. Recherche dans les √©l√©ments d'adresse sp√©cifiques
            city_elem = soup.find('span', {'data-id': 'City'})
            if city_elem:
                city = city_elem.get_text(strip=True)
                logger.debug(f"üèôÔ∏è Ville trouv√©e (data-id): {city}")
                return city
            
            # 2. Recherche dans les √©l√©ments d'adresse g√©n√©riques
            address_selectors = [
                'span[data-id="Address"]',
                'div.address',
                'span.address',
                '.property-address',
                '[data-id="PropertyAddress"]'
            ]
            
            for selector in address_selectors:
                elem = soup.select_one(selector)
                if elem:
                    text = elem.get_text(strip=True)
                    # Extraire la ville depuis l'adresse compl√®te
                    city = self._extract_city_from_address(text)
                    if city:
                        logger.debug(f"üèôÔ∏è Ville trouv√©e (s√©lecteur {selector}): {city}")
                        return city
            
            # 3. Recherche dans le contenu de la page selon la configuration
            page_text = soup.get_text()
            
            if self.config and hasattr(self.config, 'locations_searched'):
                # Utiliser les localisations de la configuration
                city_keywords = []
                for location in self.config.locations_searched:
                    if hasattr(location, 'value'):
                        city_keywords.append(location.value)
                    elif isinstance(location, dict) and 'value' in location:
                        city_keywords.append(location['value'])
                
                if city_keywords:
                    logger.debug(f"üèôÔ∏è Villes de la config: {city_keywords}")
                    for keyword in city_keywords:
                        if keyword in page_text:
                            logger.debug(f"üèôÔ∏è Ville trouv√©e (config): {keyword}")
                            return keyword
            
            # Fallback intelligent si pas de config
            logger.debug("üèôÔ∏è Pas de config, recherche intelligente dans le texte")
            # Chercher des mots qui ressemblent √† des villes (commen√ßant par majuscule, longueur > 3)
            words = page_text.split()
            for word in words:
                word = word.strip('.,!?;:')
                if len(word) > 3 and word[0].isupper() and word.isalpha():
                    logger.debug(f"üèôÔ∏è Ville candidate trouv√©e: {word}")
                    return word
            
            # 4. Recherche alternative dans l'URL ou le titre
            title_elem = soup.find('title')
            if title_elem:
                title_text = title_elem.get_text()
                # Format: "Triplex √† vendre - Chambly"
                city_match = re.search(r'-\s*([^-]+)\s*$', title_text)
                if city_match:
                    city = city_match.group(1).strip()
                    logger.debug(f"üèôÔ∏è Ville trouv√©e (titre): {city}")
                    return city
            
            logger.warning("‚ö†Ô∏è Aucune ville trouv√©e dans la page")
            return None
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur extraction ville: {e}")
            return None
    
    def _extract_street_from_address(self, address_text: str) -> Optional[str]:
        """Extrait la rue depuis un texte d'adresse compl√®te"""
        try:
            # Format: "608 - 612, boulevard Brassard, Chambly"
            # Extraire la partie avant la ville (num√©ro + nom de rue)
            parts = address_text.split(',')
            if len(parts) >= 3:
                # Prendre les 2 premi√®res parties : "608 - 612" + "boulevard Brassard"
                street_part = f"{parts[0].strip()}, {parts[1].strip()}"
                logger.debug(f"üè† Rue compl√®te extraite: {street_part}")
                return street_part
            elif len(parts) >= 2:
                # Fallback : juste la premi√®re partie si pas assez de parties
                street_part = parts[0].strip()
                logger.debug(f"üè† Partie rue extraite (fallback): {street_part}")
                return street_part
            
            return None
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur extraction rue depuis adresse: {e}")
            return None
    
    def _extract_city_from_address(self, address_text: str) -> Optional[str]:
        """Extrait la ville depuis un texte d'adresse"""
        try:
            # Patterns courants pour les adresses canadiennes
            patterns = [
                r'([A-Za-z√Ä-√ø]+),\s*QC?\s*[A-Z]\d[A-Z]\s*\d[A-Z]\d',  # Ville, QC A1A 1A1
                r'([A-Za-z√Ä-√ø]+),\s*Qu√©bec',  # Ville, Qu√©bec
                r'([A-Za-z√Ä-√ø]+),\s*Canada',  # Ville, Canada
                r'([A-Za-z√Ä-√ø]+)\s*\(QC\)',  # Ville (QC)
            ]
            
            for pattern in patterns:
                match = re.search(pattern, address_text)
                if match:
                    city = match.group(1).strip()
                    logger.debug(f"üèôÔ∏è Ville extraite du pattern: {city}")
                    return city
            
            # Si pas de pattern, chercher des mots qui ressemblent √† des villes
            words = address_text.split(',')
            for word in words:
                word = word.strip()
                if len(word) > 2 and word[0].isupper() and word.isalpha():
                    logger.debug(f"üèôÔ∏è Ville candidate trouv√©e: {word}")
                    return word
            
            return None
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur extraction ville depuis adresse: {e}")
            return None
    
    def _extract_region(self, soup: BeautifulSoup) -> str:
        """Extrait la r√©gion depuis le HTML"""
        try:
            # 1. Recherche dans le meta tag avec itemprop="name"
            meta_name = soup.find('meta', {'itemprop': 'name'})
            if meta_name:
                content = meta_name.get('content', '')
                # Format: "Triplex √† vendre √† Chambly, Mont√©r√©gie, 608 - 612, boulevard Brassard, 10001989 - Centris.ca"
                region_match = re.search(r'√†\s+([^,]+),\s+([^,]+),', content)
                if region_match:
                    region = region_match.group(2).strip()
                    logger.debug(f"üèõÔ∏è R√©gion trouv√©e (meta name): {region}")
                    return region
            
            # 2. Recherche dans le titre de la page
            title_elem = soup.find('title')
            if title_elem:
                title_text = title_elem.get_text()
                # Format: "Triplex √† vendre - Chambly, Mont√©r√©gie"
                region_match = re.search(r'([^,]+),\s*([^,\s-]+)\s*$', title_text)
                if region_match:
                    region = region_match.group(2).strip()
                    logger.debug(f"üèõÔ∏è R√©gion trouv√©e (titre): {region}")
                    return region
            
            # 3. Recherche dans le contenu de la page selon la configuration
            page_text = soup.get_text()
            
            if self.config and hasattr(self.config, 'locations_searched'):
                # Utiliser les r√©gions de la configuration si disponibles
                region_keywords = []
                for location in self.config.locations_searched:
                    if hasattr(location, 'region'):
                        region_keywords.append(location.region)
                    elif isinstance(location, dict) and 'region' in location:
                        region_keywords.append(location['region'])
                
                if region_keywords:
                    logger.debug(f"üèõÔ∏è R√©gions de la config: {region_keywords}")
                    for keyword in region_keywords:
                        if keyword in page_text:
                            logger.debug(f"üèõÔ∏è R√©gion trouv√©e (config): {keyword}")
                            return keyword
            
            # Fallback intelligent si pas de config
            logger.debug("üèõÔ∏è Pas de config, recherche intelligente dans le texte")
            # Chercher des mots qui ressemblent √† des r√©gions
            words = page_text.split()
            for word in words:
                word = word.strip('.,!?;:')
                if len(word) > 3 and word[0].isupper() and word.isalpha():
                    logger.debug(f"üèõÔ∏è R√©gion candidate trouv√©e: {word}")
                    return word
            
            # 4. Fallback par d√©faut
            logger.debug("üèõÔ∏è R√©gion non trouv√©e, utilisation du d√©faut: Qu√©bec")
            return "Qu√©bec"
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur extraction r√©gion: {e}")
            return "Qu√©bec"
    
    def _extract_postal_code(self, soup: BeautifulSoup) -> Optional[str]:
        """Extrait le code postal depuis le HTML"""
        try:
            # Recherche dans les √©l√©ments d'adresse
            postal_elem = soup.find('span', {'data-id': 'PostalCode'})
            if postal_elem:
                postal_code = postal_elem.get_text(strip=True)
                logger.debug(f"üìÆ Code postal trouv√©: {postal_code}")
                return postal_code
            
            return None
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur extraction code postal: {e}")
            return None
    
    def _extract_country(self, soup: BeautifulSoup) -> str:
        """Extrait le pays (par d√©faut Canada)"""
        return "Canada"
    
    def _extract_coordinates(self, soup: BeautifulSoup) -> Optional[Tuple[float, float]]:
        """Extrait les coordonn√©es GPS depuis le HTML"""
        try:
            # Recherche dans les scripts JavaScript
            scripts = soup.find_all('script')
            for script in scripts:
                if script.string:
                    # Recherche des coordonn√©es dans le JavaScript
                    lat_match = re.search(r'var\s+lat\s*=\s*([-\d.]+)', script.string)
                    lng_match = re.search(r'var\s+lng\s*=\s*([-\d.]+)', script.string)
                    
                    if lat_match and lng_match:
                        try:
                            lat = float(lat_match.group(1))
                            lng = float(lng_match.group(1))
                            logger.debug(f"üìç Coordonn√©es GPS extraites: {lat}, {lng}")
                            return (lat, lng)
                        except ValueError:
                            logger.debug(f"‚ö†Ô∏è Coordonn√©es non num√©riques: {lat_match.group(1)}, {lng_match.group(1)}")
            
            # Recherche alternative dans les m√©tadonn√©es
            meta_lat = soup.find('meta', {'name': 'latitude'})
            meta_lng = soup.find('meta', {'name': 'longitude'})
            
            if meta_lat and meta_lng:
                try:
                    lat = float(meta_lat.get('content'))
                    lng = float(meta_lng.get('content'))
                    logger.debug(f"üìç Coordonn√©es GPS (meta): {lat}, {lng}")
                    return (lat, lng)
                except ValueError:
                    logger.debug(f"‚ö†Ô∏è Coordonn√©es meta non num√©riques")
            
            return None
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur extraction coordonn√©es: {e}")
            return None
    
    def _build_full_address(self, address_data: dict) -> str:
        """Construit l'adresse compl√®te √† partir des composants"""
        try:
            parts = []
            
            if address_data.get('street'):
                parts.append(address_data['street'])
            
            if address_data.get('city'):
                parts.append(address_data['city'])
            
            if address_data.get('region'):
                parts.append(address_data['region'])
            
            if address_data.get('postal_code'):
                parts.append(address_data['postal_code'])
            
            if address_data.get('country'):
                parts.append(address_data['country'])
            
            full_address = ', '.join(parts)
            logger.debug(f"üìç Adresse compl√®te construite: {full_address}")
            return full_address
            
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Erreur construction adresse compl√®te: {e}")
            return ""
