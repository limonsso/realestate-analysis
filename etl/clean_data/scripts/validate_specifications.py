#!/usr/bin/env python3
"""
Script de validation des sp√©cifications du projet de nettoyage immobilier
V√©rifie que toutes les exigences du real_estate_prompt.md sont respect√©es
"""

import sys
from pathlib import Path
import importlib
import logging

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SpecificationValidator:
    """Valide que toutes les sp√©cifications sont respect√©es"""
    
    def __init__(self):
        self.validation_results = {}
        self.passed_checks = 0
        self.total_checks = 0
        self.failed_checks = []
    
    def validate_all_specifications(self):
        """Valide toutes les sp√©cifications"""
        logger.info("üîç VALIDATION COMPL√àTE DES SP√âCIFICATIONS")
        logger.info("=" * 60)
        
        # Validation de la structure du projet
        self._validate_project_structure()
        
        # Validation de la stack technologique
        self._validate_tech_stack()
        
        # Validation des phases de nettoyage
        self._validate_cleaning_phases()
        
        # Validation des fonctionnalit√©s
        self._validate_functionality()
        
        # Validation des livrables
        self._validate_deliverables()
        
        # Affichage du r√©sum√©
        self._display_summary()
        
        return self.passed_checks == self.total_checks
    
    def _validate_project_structure(self):
        """Valide la structure du projet"""
        logger.info("üìÅ VALIDATION DE LA STRUCTURE DU PROJET")
        
        # V√©rifier les dossiers requis
        required_dirs = [
            "inputs", "outputs", "src", "tests", "docs", "examples"
        ]
        
        for directory in required_dirs:
            self.total_checks += 1
            if Path(directory).exists():
                logger.info(f"  ‚úÖ Dossier {directory} pr√©sent")
                self.passed_checks += 1
            else:
                logger.error(f"  ‚ùå Dossier {directory} manquant")
                self.failed_checks.append(f"Dossier {directory} manquant")
        
        # V√©rifier la structure src
        src_structure = [
            "src/__init__.py",
            "src/core/__init__.py",
            "src/core/cleaner.py",
            "src/core/simple_cleaner.py",
            "src/core/config.py",
            "src/exporters/__init__.py",
            "src/exporters/data_exporter.py",
            "src/exporters/report_exporter.py",
            "src/validators/__init__.py",
            "src/validators/data_validator.py",
            "src/utils/__init__.py",
            "src/utils/data_utils.py"
        ]
        
        for file_path in src_structure:
            self.total_checks += 1
            if Path(file_path).exists():
                logger.info(f"  ‚úÖ Fichier {file_path} pr√©sent")
                self.passed_checks += 1
            else:
                logger.error(f"  ‚ùå Fichier {file_path} manquant")
                self.failed_checks.append(f"Fichier {file_path} manquant")
        
        # V√©rifier les fichiers principaux
        main_files = [
            "main.py", "requirements.txt", "README.md"
        ]
        
        for file_path in main_files:
            self.total_checks += 1
            if Path(file_path).exists():
                logger.info(f"  ‚úÖ Fichier {file_path} pr√©sent")
                self.passed_checks += 1
            else:
                logger.error(f"  ‚ùå Fichier {file_path} manquant")
                self.failed_checks.append(f"Fichier {file_path} manquant")
    
    def _validate_tech_stack(self):
        """Valide la stack technologique requise"""
        logger.info("üõ†Ô∏è VALIDATION DE LA STACK TECHNOLOGIQUE")
        
        # Technologies Python requises
        required_packages = [
            "pandas", "numpy", "geopandas", "folium", "geopy",
            "matplotlib", "seaborn", "plotly", "scipy", "sklearn"
        ]
        
        for package in required_packages:
            self.total_checks += 1
            try:
                importlib.import_module(package)
                logger.info(f"  ‚úÖ Package {package} disponible")
                self.passed_checks += 1
            except ImportError:
                logger.error(f"  ‚ùå Package {package} non disponible")
                self.failed_checks.append(f"Package {package} non disponible")
        
        # V√©rifier Python 3.9+
        self.total_checks += 1
        python_version = sys.version_info
        if python_version.major == 3 and python_version.minor >= 9:
            logger.info(f"  ‚úÖ Python {python_version.major}.{python_version.minor} compatible")
            self.passed_checks += 1
        else:
            logger.error(f"  ‚ùå Python {python_version.major}.{python_version.minor} non compatible (3.9+ requis)")
            self.failed_checks.append(f"Python {python_version.major}.{python_version.minor} non compatible")
    
    def _validate_cleaning_phases(self):
        """Valide que toutes les phases de nettoyage sont impl√©ment√©es"""
        logger.info("üîç VALIDATION DES PHASES DE NETTOYAGE")
        
        # Phase 1: Audit et diagnostic
        self.total_checks += 1
        if self._check_phase1_implementation():
            logger.info("  ‚úÖ Phase 1: Audit et diagnostic impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Phase 1: Audit et diagnostic manquante")
            self.failed_checks.append("Phase 1: Audit et diagnostic manquante")
        
        # Phase 2: Nettoyage intelligent
        self.total_checks += 1
        if self._check_phase2_implementation():
            logger.info("  ‚úÖ Phase 2: Nettoyage intelligent impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Phase 2: Nettoyage intelligent manquante")
            self.failed_checks.append("Phase 2: Nettoyage intelligent manquante")
        
        # Phase 3: Enrichissement intelligent
        self.total_checks += 1
        if self._check_phase3_implementation():
            logger.info("  ‚úÖ Phase 3: Enrichissement intelligent impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Phase 3: Enrichissement intelligent manquante")
            self.failed_checks.append("Phase 3: Enrichissement intelligent manquante")
        
        # Phase 4: Validation et contr√¥le qualit√©
        self.total_checks += 1
        if self._check_phase4_implementation():
            logger.info("  ‚úÖ Phase 4: Validation et contr√¥le qualit√© impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Phase 4: Validation et contr√¥le qualit√© manquante")
            self.failed_checks.append("Phase 4: Validation et contr√¥le qualit√© manquante")
        
        # Phase 5: Pr√©paration pour l'analyse
        self.total_checks += 1
        if self._check_phase5_implementation():
            logger.info("  ‚úÖ Phase 5: Pr√©paration pour l'analyse impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Phase 5: Pr√©paration pour l'analyse manquante")
            self.failed_checks.append("Phase 5: Pr√©paration pour l'analyse manquante")
    
    def _check_phase1_implementation(self):
        """V√©rifie l'impl√©mentation de la Phase 1"""
        try:
            # V√©rifier que la classe RealEstateDataCleaner a la m√©thode phase1_audit_diagnostic
            from src.core.cleaner import RealEstateDataCleaner
            return hasattr(RealEstateDataCleaner, 'phase1_audit_diagnostic')
        except:
            return False
    
    def _check_phase2_implementation(self):
        """V√©rifie l'impl√©mentation de la Phase 2"""
        try:
            from src.core.cleaner import RealEstateDataCleaner
            return hasattr(RealEstateDataCleaner, 'phase2_cleaning_intelligent')
        except:
            return False
    
    def _check_phase3_implementation(self):
        """V√©rifie l'impl√©mentation de la Phase 3"""
        try:
            from src.core.cleaner import RealEstateDataCleaner
            return hasattr(RealEstateDataCleaner, 'phase3_enrichment_intelligent')
        except:
            return False
    
    def _check_phase4_implementation(self):
        """V√©rifie l'impl√©mentation de la Phase 4"""
        try:
            from src.core.cleaner import RealEstateDataCleaner
            return hasattr(RealEstateDataCleaner, 'phase4_validation_quality_control')
        except:
            return False
    
    def _check_phase5_implementation(self):
        """V√©rifie l'impl√©mentation de la Phase 5"""
        try:
            from src.core.cleaner import RealEstateDataCleaner
            return hasattr(RealEstateDataCleaner, 'phase5_preparation_analysis')
        except:
            return False
    
    def _validate_functionality(self):
        """Valide les fonctionnalit√©s sp√©cifiques"""
        logger.info("‚ö° VALIDATION DES FONCTIONNALIT√âS")
        
        # V√©rifier la gestion des colonnes probl√©matiques
        self.total_checks += 1
        if self._check_problematic_columns_handling():
            logger.info("  ‚úÖ Gestion des colonnes probl√©matiques impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Gestion des colonnes probl√©matiques manquante")
            self.failed_checks.append("Gestion des colonnes probl√©matiques manquante")
        
        # V√©rifier la consolidation des colonnes redondantes
        self.total_checks += 1
        if self._check_column_consolidation():
            logger.info("  ‚úÖ Consolidation des colonnes redondantes impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Consolidation des colonnes redondantes manquante")
            self.failed_checks.append("Consolidation des colonnes redondantes manquante")
        
        # V√©rifier la gestion g√©ospatiale
        self.total_checks += 1
        if self._check_geospatial_handling():
            logger.info("  ‚úÖ Gestion g√©ospatiale impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Gestion g√©ospatiale manquante")
            self.failed_checks.append("Gestion g√©ospatiale manquante")
        
        # V√©rifier la cr√©ation de m√©triques
        self.total_checks += 1
        if self._check_metrics_creation():
            logger.info("  ‚úÖ Cr√©ation de m√©triques impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Cr√©ation de m√©triques manquante")
            self.failed_checks.append("Cr√©ation de m√©triques manquante")
    
    def _check_problematic_columns_handling(self):
        """V√©rifie la gestion des colonnes probl√©matiques"""
        try:
            # Ajouter le dossier src au path Python
            import sys
            from pathlib import Path
            src_path = Path(__file__).parent / "src"
            sys.path.insert(0, str(src_path))
            
            from src.utils.data_utils import DataUtils
            return hasattr(DataUtils, 'standardize_column_names')
        except Exception as e:
            logger.error(f"Erreur lors de la v√©rification: {e}")
            return False
    
    def _check_column_consolidation(self):
        """V√©rifie la consolidation des colonnes"""
        try:
            from src.utils.data_utils import DataUtils
            return (hasattr(DataUtils, 'consolidate_revenue_columns') and 
                   hasattr(DataUtils, 'consolidate_date_columns'))
        except:
            return False
    
    def _check_geospatial_handling(self):
        """V√©rifie la gestion g√©ospatiale"""
        try:
            from src.exporters.data_exporter import DataExporter
            return hasattr(DataExporter, 'export_geojson')
        except:
            return False
    
    def _check_metrics_creation(self):
        """V√©rifie la cr√©ation de m√©triques"""
        try:
            from src.utils.data_utils import DataUtils
            return (hasattr(DataUtils, 'create_financial_metrics') and 
                   hasattr(DataUtils, 'create_physical_metrics'))
        except:
            return False
    
    def _validate_deliverables(self):
        """Valide les livrables finaux"""
        logger.info("üì¶ VALIDATION DES LIVRABLES")
        
        # V√©rifier l'export multi-format
        self.total_checks += 1
        if self._check_multi_format_export():
            logger.info("  ‚úÖ Export multi-format impl√©ment√©")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Export multi-format manquant")
            self.failed_checks.append("Export multi-format manquant")
        
        # V√©rifier la g√©n√©ration de rapports
        self.total_checks += 1
        if self._check_report_generation():
            logger.info("  ‚úÖ G√©n√©ration de rapports impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå G√©n√©ration de rapports manquante")
            self.failed_checks.append("G√©n√©ration de rapports manquante")
        
        # V√©rifier la validation des donn√©es
        self.total_checks += 1
        if self._check_data_validation():
            logger.info("  ‚úÖ Validation des donn√©es impl√©ment√©e")
            self.passed_checks += 1
        else:
            logger.error("  ‚ùå Validation des donn√©es manquante")
            self.failed_checks.append("Validation des donn√©es manquante")
    
    def _check_multi_format_export(self):
        """V√©rifie l'export multi-format"""
        try:
            from src.exporters.data_exporter import DataExporter
            exporter = DataExporter(Path("outputs/cleaned_data"))
            return (hasattr(exporter, 'export_csv') and 
                   hasattr(exporter, 'export_parquet') and
                   hasattr(exporter, 'export_json') and
                   hasattr(exporter, 'export_geojson'))
        except:
            return False
    
    def _check_report_generation(self):
        """V√©rifie la g√©n√©ration de rapports"""
        try:
            from src.exporters.report_exporter import ReportExporter
            return hasattr(ReportExporter, 'export_quality_report')
        except:
            return False
    
    def _check_data_validation(self):
        """V√©rifie la validation des donn√©es"""
        try:
            # Ajouter le dossier src au path Python
            import sys
            from pathlib import Path
            src_path = Path(__file__).parent / "src"
            sys.path.insert(0, str(src_path))
            
            from src.validators.data_validator import DataValidator
            return hasattr(DataValidator, 'validate_dataset')
        except Exception as e:
            logger.error(f"Erreur lors de la v√©rification: {e}")
            return False
    
    def _display_summary(self):
        """Affiche le r√©sum√© de la validation"""
        logger.info("\n" + "=" * 60)
        logger.info("üìä R√âSUM√â DE LA VALIDATION DES SP√âCIFICATIONS")
        logger.info("=" * 60)
        
        success_rate = (self.passed_checks / self.total_checks * 100) if self.total_checks > 0 else 0
        
        logger.info(f"‚úÖ Tests r√©ussis: {self.passed_checks}/{self.total_checks}")
        logger.info(f"üìà Taux de succ√®s: {success_rate:.1f}%")
        
        if self.failed_checks:
            logger.error(f"‚ùå √âchecs d√©tect√©s: {len(self.failed_checks)}")
            for failure in self.failed_checks:
                logger.error(f"  - {failure}")
        else:
            logger.info("üéâ Toutes les sp√©cifications sont respect√©es !")
        
        logger.info("=" * 60)

def main():
    """Fonction principale"""
    logger.info("üöÄ D√âMARRAGE DE LA VALIDATION DES SP√âCIFICATIONS")
    
    validator = SpecificationValidator()
    success = validator.validate_all_specifications()
    
    if success:
        logger.info("üéâ VALIDATION R√âUSSIE - Toutes les sp√©cifications sont respect√©es !")
        return 0
    else:
        logger.error("‚ùå VALIDATION √âCHOU√âE - Certaines sp√©cifications ne sont pas respect√©es")
        return 1

if __name__ == "__main__":
    exit(main())
